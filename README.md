# Local Object Detector

Un servicio local conteinerizado en Python para detecci√≥n de objetos (persona y coche) usando YOLOv8. El servicio proporciona una API HTTP que recibe im√°genes y devuelve detecciones en formato JSON.

## Caracter√≠sticas

- ‚úÖ Detecci√≥n de **personas** y **coches** usando YOLOv8
- ‚úÖ API REST con FastAPI
- ‚úÖ Conteinerizado con Docker 
- ‚úÖ Optimizado para CPU (sin dependencia de GPU)
- ‚úÖ Validaci√≥n robusta de entrada
- ‚úÖ Logs detallados y m√©tricas de rendimiento
- ‚úÖ Manejo completo de errores

## Arquitectura

```
Local Object Detector
‚îú‚îÄ‚îÄ FastAPI (servidor web)
‚îú‚îÄ‚îÄ YOLOv8 (modelo de detecci√≥n)
‚îú‚îÄ‚îÄ PIL + OpenCV (procesamiento de im√°genes)
‚îî‚îÄ‚îÄ Docker (conteinerizaci√≥n)
```

## Instalaci√≥n y Ejecuci√≥n

### Opci√≥n 1: Docker Compose (Recomendado para Producci√≥n)

#### Ejecutar el servicio
```bash
# Construir e iniciar el servicio
docker-compose up -d

# Ver logs en tiempo real
docker-compose logs -f

# Parar el servicio
docker-compose down
```

### Opci√≥n 2: Docker Manual

#### Construir la imagen
```bash
docker build -t local-detector:latest .
```

#### Ejecutar el contenedor
```bash
docker run --rm -p 8000:8000 local-detector:latest
```

El servicio estar√° disponible en: http://localhost:8000

### Opci√≥n 3: Instalaci√≥n local

#### Prerrequisitos
- Python 3.11+
- pip

#### Instalaci√≥n
```bash
# Clonar el repositorio
git clone <repository-url>
cd turingchallenge-reto-3

# Crear entorno virtual
python -m venv venv
source venv/bin/activate  # Linux/Mac
# o
venv\Scripts\activate     # Windows

# Instalar dependencias
pip install -r requirements.txt

# Ejecutar el servicio
python main.py
```

## API Reference

### Health Check

Verifica que el servicio est√© funcionando correctamente.

**Endpoint:** `GET /health`

**Respuesta:**
```json
{
  "status": "healthy",
  "service": "Local Object Detector",
  "version": "1.0.0"
}
```

### Detecci√≥n de Objetos

Realiza detecci√≥n de personas y coches en una imagen.

**Endpoint:** `POST /infer`

**Content-Type:** `multipart/form-data`

#### Par√°metros

| Par√°metro | Tipo | Requerido | Por defecto | Descripci√≥n |
|-----------|------|-----------|-------------|-------------|
| `image` | File | ‚úÖ S√≠ | - | Archivo de imagen (JPEG/PNG, m√°x. 10MB) |
| `conf` | float | ‚ùå No | 0.25 | Umbral de confianza (0.0-1.0) |
| `iou` | float | ‚ùå No | 0.45 | Umbral IoU para supresi√≥n no m√°xima (0.0-1.0) |
| `max_detections` | int | ‚ùå No | 300 | N√∫mero m√°ximo de detecciones (1-1000) |

#### Descripci√≥n de par√°metros

- **conf (confidence)**: Umbral de confianza m√≠nimo para considerar una detecci√≥n v√°lida. Valores m√°s altos = menos detecciones pero m√°s precisas.
- **iou (Intersection over Union)**: Umbral para eliminar detecciones duplicadas. Valores m√°s altos = permite m√°s detecciones solapadas.
- **max_detections**: L√≠mite m√°ximo de objetos a detectar en la imagen.

#### Formato de respuesta JSON

```json
{
  "model": "yolov8n.pt",
  "time_ms": 150.25,
  "image": {
    "width": 1920,
    "height": 1080
  },
  "detections": [
    {
      "class_id": 0,
      "class_name": "person",
      "confidence": 0.85,
      "bbox_xyxy": [100, 200, 300, 500],
      "bbox_xywh": [200, 350, 200, 300],
      "bbox_norm_xyxy": [0.052, 0.185, 0.156, 0.463]
    }
  ]
}
```

#### Descripci√≥n de campos de respuesta

- **model**: Nombre del modelo YOLO utilizado
- **time_ms**: Tiempo de inferencia en milisegundos
- **image**: Dimensiones de la imagen procesada
- **detections**: Lista de objetos detectados
  - **class_id**: ID num√©rico de la clase (0=person, 2=car)
  - **class_name**: Nombre legible de la clase
  - **confidence**: Confianza de la detecci√≥n (0.0-1.0)
  - **bbox_xyxy**: Bounding box formato [x1, y1, x2, y2] en p√≠xeles
  - **bbox_xywh**: Bounding box formato [x_center, y_center, width, height] en p√≠xeles
  - **bbox_norm_xyxy**: Bounding box normalizado (valores 0.0-1.0)

## Ejemplos de Uso

### Ejemplo con curl

#### Test b√°sico de salud
```bash
curl http://localhost:8000/health
```

#### Detecci√≥n b√°sica
```bash
curl -X POST \
  http://localhost:8000/infer \
  -F "image=@test_person.jpg"
```

#### Detecci√≥n con par√°metros personalizados
```bash
curl -X POST \
  http://localhost:8000/infer \
  -F "image=@test_person.jpg" \
  -F "conf=0.5" \
  -F "iou=0.3" \
  -F "max_detections=100"
```

#### Ejemplo con archivo remoto
```bash
# Descargar imagen de ejemplo
wget -O example.jpg "https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d"

# Realizar detecci√≥n
curl -X POST \
  http://localhost:8000/infer \
  -F "image=@example.jpg" \
  -F "conf=0.3"
```

### Ejemplo con Python

#### Instalaci√≥n de dependencias para el cliente
```bash
pip install requests pillow
```

#### Script b√°sico de Python
```python
import requests
import json

def detect_objects(image_path, conf=0.25, iou=0.45, max_detections=300):
    """
    Realiza detecci√≥n de objetos usando el servicio local
    
    Args:
        image_path (str): Ruta al archivo de imagen
        conf (float): Umbral de confianza
        iou (float): Umbral IoU
        max_detections (int): N√∫mero m√°ximo de detecciones
    
    Returns:
        dict: Resultado de la detecci√≥n
    """
    url = "http://localhost:8000/infer"
    
    # Preparar archivos y datos
    with open(image_path, 'rb') as img_file:
        files = {'image': img_file}
        data = {
            'conf': conf,
            'iou': iou,
            'max_detections': max_detections
        }
        
        # Realizar petici√≥n
        response = requests.post(url, files=files, data=data)
    
    # Verificar respuesta
    if response.status_code == 200:
        return response.json()
    else:
        raise Exception(f"Error {response.status_code}: {response.text}")

# Ejemplo de uso
if __name__ == "__main__":
    try:
        # Verificar salud del servicio
        health = requests.get("http://localhost:8000/health")
        print("Servicio disponible:", health.json())
        
        # Realizar detecci√≥n
        result = detect_objects("test_person.jpg", conf=0.5)
        
        print(f"\nDetecci√≥n completada en {result['time_ms']:.2f}ms")
        print(f"Imagen: {result['image']['width']}x{result['image']['height']} p√≠xeles")
        print(f"Detecciones encontradas: {len(result['detections'])}")
        
        # Mostrar detecciones
        for i, det in enumerate(result['detections']):
            print(f"\nDetecci√≥n {i+1}:")
            print(f"  Clase: {det['class_name']} (ID: {det['class_id']})")
            print(f"  Confianza: {det['confidence']:.3f}")
            print(f"  Posici√≥n: {det['bbox_xyxy']}")
            
    except Exception as e:
        print(f"Error: {e}")
```

#### Script avanzado con procesamiento de m√∫ltiples im√°genes
```python
import requests
import json
from pathlib import Path
import time

class ObjectDetectorClient:
    def __init__(self, base_url="http://localhost:8000"):
        self.base_url = base_url
        
    def health_check(self):
        """Verificar estado del servicio"""
        response = requests.get(f"{self.base_url}/health")
        return response.json() if response.status_code == 200 else None
        
    def detect(self, image_path, **kwargs):
        """Detectar objetos en una imagen"""
        with open(image_path, 'rb') as f:
            files = {'image': f}
            response = requests.post(f"{self.base_url}/infer", files=files, data=kwargs)
            
        if response.status_code == 200:
            return response.json()
        else:
            raise Exception(f"Error {response.status_code}: {response.text}")
    
    def batch_detect(self, image_folder, pattern="*.jpg", **detection_kwargs):
        """Procesar m√∫ltiples im√°genes"""
        image_folder = Path(image_folder)
        results = []
        
        for image_path in image_folder.glob(pattern):
            print(f"Procesando {image_path.name}...")
            
            try:
                start_time = time.time()
                result = self.detect(image_path, **detection_kwargs)
                end_time = time.time()
                
                result['filename'] = image_path.name
                result['processing_time'] = end_time - start_time
                results.append(result)
                
                print(f"  ‚úÖ {len(result['detections'])} detecciones en {result['time_ms']:.1f}ms")
                
            except Exception as e:
                print(f"  ‚ùå Error: {e}")
                
        return results

# Ejemplo de uso
if __name__ == "__main__":
    client = ObjectDetectorClient()
    
    # Verificar servicio
    if not client.health_check():
        print("‚ùå Servicio no disponible")
        exit(1)
    
    print("‚úÖ Servicio disponible")
    
    # Procesar m√∫ltiples im√°genes
    results = client.batch_detect("./images", "*.jpg", conf=0.3, max_detections=50)
    
    # Estad√≠sticas generales
    total_images = len(results)
    total_detections = sum(len(r['detections']) for r in results)
    avg_time = sum(r['time_ms'] for r in results) / total_images if total_images > 0 else 0
    
    print(f"\nüìä Estad√≠sticas:")
    print(f"  Im√°genes procesadas: {total_images}")
    print(f"  Total detecciones: {total_detections}")
    print(f"  Tiempo promedio: {avg_time:.1f}ms")
```

## C√≥digos de Estado HTTP

| C√≥digo | Descripci√≥n | Causa com√∫n |
|--------|-------------|-------------|
| 200 | OK | Detecci√≥n exitosa |
| 400 | Bad Request | Formato de imagen no soportado o imagen corrupta |
| 413 | Payload Too Large | Imagen mayor a 10MB |
| 422 | Unprocessable Entity | Par√°metros inv√°lidos (conf, iou, max_detections fuera de rango) |
| 500 | Internal Server Error | Error interno del modelo o servidor |

## Logs y Monitoreo

El servicio genera logs detallados que incluyen:

- **M√©tricas de rendimiento**: Tiempo de inferencia, tama√±o de imagen, n√∫mero de detecciones
- **Informaci√≥n de peticiones**: Archivos procesados, par√°metros utilizados
- **Errores y advertencias**: Problemas de validaci√≥n, errores internos

Ejemplo de log de rendimiento:
```
2024-08-30 14:30:15 - app.app - INFO - PERFORMANCE_METRICS - file='test.jpg' image_size=1920x1080 file_size_bytes=245760 parameters=conf:0.25,iou:0.45,max_det:300 inference_time_ms=150.25 total_time_ms=165.30 processing_overhead_ms=15.05 detections_total=3 detections_by_class={'person': 2, 'car': 1}
```

## Resoluci√≥n de Problemas

### Problemas Comunes

#### El contenedor no inicia
```bash
# Verificar logs del contenedor
docker logs <container-id>

# Verificar que el puerto est√© libre
lsof -i :8000  # Linux/Mac
netstat -ano | findstr :8000  # Windows
```

#### Error "Model file not found"
```bash
# Verificar que existe el archivo del modelo
ls -la models/

# Reconstruir la imagen Docker
docker build --no-cache -t local-detector:latest .
```

#### Respuestas lentas
- Reducir `max_detections` para im√°genes con muchos objetos
- Usar im√°genes de menor resoluci√≥n cuando sea posible
- Aumentar `conf` para reducir detecciones de baja confianza

#### Demasiadas detecciones falsas
- Aumentar el par√°metro `conf` (ej: 0.5 o 0.7)
- Ajustar `iou` para eliminar detecciones solapadas

## Rendimiento

### M√©tricas t√≠picas (CPU Intel i5, imagen 720p)
- **Tiempo de inferencia**: 150-300ms
- **Throughput**: ~10-15 req/s
- **Memoria**: ~2-3GB (incluyendo modelo)

### Recomendaciones de optimizaci√≥n
- Usar im√°genes de menor resoluci√≥n cuando sea posible
- Ajustar `max_detections` seg√∫n las necesidades
- Considerar usar `yolov8s.pt` si se requiere mayor precisi√≥n

## Desarrollo

### Estructura del proyecto
```
turingchallenge-reto-3/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ app.py          # FastAPI app principal
‚îÇ   ‚îî‚îÄ‚îÄ config.py       # Configuraci√≥n
‚îú‚îÄ‚îÄ models/             # Modelos YOLO
‚îú‚îÄ‚îÄ tests/             # Tests unitarios y de integraci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ conftest.py     # Fixtures compartidas
‚îÇ   ‚îî‚îÄ‚îÄ test_basic_setup.py
‚îú‚îÄ‚îÄ Dockerfile         # Imagen Docker
‚îú‚îÄ‚îÄ docker-compose.yml # Configuraci√≥n de producci√≥n
‚îú‚îÄ‚îÄ main.py           # Punto de entrada
‚îú‚îÄ‚îÄ requirements.txt  # Dependencias Python
‚îú‚îÄ‚îÄ run_tests_complete.py # Script completo de testing
‚îî‚îÄ‚îÄ README.md         # Esta documentaci√≥n
```

### Comandos de Testing

```bash
# Ejecutar todos los tests con cobertura
python run_tests_complete.py

# Modo r√°pido (sin tests de rendimiento)
python run_tests_complete.py --quick

# Solo cobertura (unit + integration)
python run_tests_complete.py --coverage-only

# Tests espec√≠ficos por categor√≠a
pytest tests/unit/ -v -m unit
pytest tests/integration/ -v -m integration
pytest tests/performance/ -v -m performance

# Test individual
pytest tests/test_basic_setup.py::test_function_name -v
```

### Variables de entorno

| Variable | Descripci√≥n | Por defecto |
|----------|-------------|-------------|
| `MODEL_PATH` | Ruta al modelo YOLO | `models/yolov8n.pt` |
| `DEFAULT_CONF` | Confianza por defecto | `0.25` |
| `DEFAULT_IOU` | IoU por defecto | `0.45` |
| `DEFAULT_MAX_DETECTIONS` | Detecciones m√°ximas por defecto | `300` |

## Licencia

Este proyecto utiliza las siguientes dependencias principales:
- **YOLOv8 (Ultralytics)**: AGPL-3.0
- **FastAPI**: MIT
- **PyTorch**: BSD-3-Clause

Revisar las licencias individuales para uso comercial.